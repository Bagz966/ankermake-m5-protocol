def header():
    return \
        "## ------------------------------------------\n" \
        "## Generated by Transwarp\n"                     \
        "##\n"                                            \
        "## THIS FILE IS AUTOMATICALLY GENERATED.\n"      \
        "## DO NOT EDIT. ALL CHANGES WILL BE LOST.\n"     \
        "## ------------------------------------------"

_parsetable = {
    "array": "Array",
    "string": "String",
    "zeroes": "Zeroes",
    "magic": "Magic",
    "tail": "Tail",
}

def magic_default(tp):
    size = int(str(tp[0]))
    value = int(str(tp[1]), 16)
    hexval = f"%0{size * 2}x" % value
    return bytes.fromhex(hexval)

def typename(field):
    tp = field.type

    if tp.name == "zeroes":
        return f"bytes = field(repr=False, kw_only=True, default='\\x00' * {tp[0]})"
    elif tp.name == "string":
        return "bytes"
    elif tp.name == "magic":
        return f"bytes = field(repr=False, kw_only=True, default={magic_default(tp)})"
    elif tp.name == "tail":
        return "bytes"
    elif tp.name == "array":
        if len(tp.args) in {1, 2}:
            return f"list[{tp[0]}]"
        else:
            raise ValueError(f"bad array type: {tp}")
    else:
        return tp.name

def typeparse(field, p):
    tp = field.type
    name = _parsetable.get(tp.name, tp.name)
    return f"{name}.parse({', '.join([p] + [t.name for t in tp.args])})"

def typepack(field):
    tp = field.type
    name = tp.name

    if name in _parsetable:
        cls = _parsetable[name]
        return f"{cls}.pack(self.{field.name}, {tp[0]})"
    else:
        return f"{name}.pack(self.{field.name})"
